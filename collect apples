def minTimeToCollectApples(n, edges, hasApple):
    # Create an adjacency list representation of the tree
    graph = {i: [] for i in range(n)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    
    # Perform DFS traversal from vertex 0
    def dfs(node, parent):
        time = 0
        for neighbor in graph[node]:
            if neighbor != parent:
                time += dfs(neighbor, node)
        # If the current vertex has an apple or if any of its child nodes have apples,
        # add the time taken to reach this vertex (2 * edge traversals)
        if (hasApple[node] or time > 0) and node != 0:
            return time + 2
        return time
    
    # Return the total time taken to collect all apples
    return dfs(0, -1)

# Example usage:
n = 7
edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]]
hasApple = [False,True,False,False,True,True,False]
print(minTimeToCollectApples(n, edges, hasApple))  # Output can be 8
