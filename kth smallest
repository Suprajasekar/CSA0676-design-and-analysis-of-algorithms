import heapq

def kthSmallest(mat, k):
    m = len(mat)
    n = len(mat[0])
    
    # Initialize the min-heap with the smallest possible sum
    min_heap = [(sum(row[0] for row in mat), [0] * m)]
    
    # To avoid pushing duplicate sums into the heap
    seen = set()
    seen.add(tuple([0] * m))
    
    # Extract the smallest sum k-1 times
    for _ in range(k - 1):
        current_sum, indices = heapq.heappop(min_heap)
        
        for i in range(m):
            if indices[i] + 1 < n:
                new_indices = list(indices)
                new_indices[i] += 1
                new_sum = current_sum - mat[i][indices[i]] + mat[i][new_indices[i]]
                
                if tuple(new_indices) not in seen:
                    seen.add(tuple(new_indices))
                    heapq.heappush(min_heap, (new_sum, new_indices))
    
    # The k-th smallest sum
    return heapq.heappop(min_heap)[0]

# Example usage
mat = [
    [1, 3, 11],
    [2, 4, 6]
]
k = 5
print(kthSmallest(mat, k))  # Output should be 17
